---
title: "Untitled"
format: html
editor: visual
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{R}
library(JuliaCall)
library(scales)
source("R/generate_synthetic_mutation_counts.R")
source("R/generate_synthetic_mutation_counts.R")
source("R/plot_signature.R")
source("R/initialize_prior.R")
cosmic_3.4 <- read.COSMIC.sigs(version = "v3.4")
X <- pmax(as.matrix(cosmic_3.4), 1e-10)
X <- apply(X, 2, function(x) x/sum(x))
write.csv(X, file = "data/cosmic3.4.csv")
```


```{R}
names(alpha_new) <- rownames(X)
plot.SBS.signature(x, CI = t(apply(rdir(1000, alpha_new),  2, function(x) quantile(x, c(0.05, 0.95)))))
lsa::cosine(alpha_new, x)

plot(density(apply(rdir(5000, alpha_new),  1, function(y) 1 - lsa::cosine(x, y))))
lines(density(apply(rdir(5000, x * sum(alpha_new)),  1, function(y) 1 - lsa::cosine(x, y))), col ="red")
        
x <- X[, 5]
alpha_new <- julia_call("max_density_for_dirichlet", x, 100, "concentration")
plot(alpha_new, x)
sum(alpha_new)

names(alpha_new) <- rownames(X)
plot.SBS.signature(x, CI = t(apply(rdir(1000, alpha_new),  2, function(x) quantile(x, c(0.05, 0.95)))))
lsa::cosine(alpha_new, x)

```


```{R}
# Open the output of Julia
alpha_all <- julia_eval('import Pkg; Pkg.add("MAT"); using MAT; matread("data/alpha_kl_cosmic.mat")["results"]')
dimnames(alpha_all) <- list(rownames(X), 1:200, colnames(X))
# Run the method
set.seed(42)
res_kl <- vector(mode = "list", length = ncol(X))
nsamples <- 1000
for(j in 1:ncol(X)){
  print(j)
  x <- X[, j]
  res <- matrix(NA, nrow = nsamples, ncol = length(range_kl))
  alpha_new <- alpha_all[, ,j]
  cosine_samples <- apply(alpha_new, 2, function(y) apply(rdir(nsamples, y), 1, function(z) 1 - lsa::cosine(x, z)))
  res_kl[[j]] <- cosine_samples
}
names(res_kl) <- colnames(X)

```

```{R}
# Let's now use the fixed concentration
set.seed(42)
res_fixed <- vector(mode = "list", length = ncol(X))
nsamples <- 1000
for(j in 1:ncol(X)){
  print(j)
  x <- X[, j]
  alpha_new <- sapply(1:200, function(y) x * y )
  cosine_samples <- apply(alpha_new, 2, function(y) apply(rdir(nsamples, y), 1, function(z) 1 - lsa::cosine(x, z)))
  res_fixed[[j]] <- cosine_samples
}
names(res_fixed) <- colnames(X)
```


```{R}
# Let's now look at the constrained concentration
alpha_conc <- julia_eval('import Pkg; Pkg.add("MAT"); using MAT; matread("data/alpha_kl_cosmic_concentration.mat")["results"]')
dimnames(alpha_conc) <- list(rownames(X), 1:200, colnames(X))

set.seed(42)
res_conc <- vector(mode = "list", length = ncol(X))
nsamples <- 1000
for(j in 1:ncol(X)){
  print(j)
  x <- X[, j]
  cosine_samples <- apply(alpha_conc[, , j], 2, function(y) apply(rdir(nsamples, y), 1, function(z) 1 - lsa::cosine(x, z)))
  res_conc[[j]] <- cosine_samples
}
names(res_conc) <- colnames(X)
```


```{R}
avg_cos <- lapply(res_kl, function(x) apply(x, 2, sd))
avg_cos_fixed <- lapply(res_fixed, function(x) apply(x, 2, sd))

par(mfrow = c(1, 2))

plot(avg_cos_fixed[[1]], type = "l", ylim = c(0, 0.4), ylab = "stdev. of cosine error", xlab = "alpha", col = alpha("black", 0.3), main = "Fixed")
for(j in 2:length(avg_cos_fixed)){
  lines(avg_cos_fixed[[j]], col = alpha("black", 0.3))
}

plot(avg_cos[[1]], type = "l", ylim = c(0, 0.4), ylab = "stdev. of cosine error", xlab = "theta", col = alpha("black", 0.3), , main = "KL")
for(j in 2:length(avg_cos)){
  lines(avg_cos[[j]], col = alpha("black", 0.3))
}
```

```{R}
avg_cos_kl <- lapply(res_kl, function(x) apply(x, 2, function(y) c("mean" = mean(y),
                                                                    "stdev" = sd(y),
                                                                    "lowCI" = quantile(y, 0.25), 
                                                                    "highCI" = quantile(y, 0.75))))

avg_cos_conc <- lapply(res_conc, function(x) apply(x, 2, function(y) c("mean" = mean(y),
                                                                    "stdev" = sd(y),
                                                                    "lowCI" = quantile(y, 0.25), 
                                                                    "highCI" = quantile(y, 0.75))))

avg_cos_fixed <- lapply(res_fixed, function(x) apply(x, 2, function(y) c("mean" = mean(y),
                                                                    "stdev" = sd(y),
                                                                    "lowCI" = quantile(y, 0.25), 
                                                                    "highCI" = quantile(y, 0.75))))

# par(mfrow = c(1, 2))
# plot(avg_cos_fixed[[1]][2, ], type = "l", ylim = c(0, 0.4), ylab = "stdev. of cosine error", xlab = "alpha", col = alpha("black", 0.3), main = "Fixed")
# for(j in 2:length(avg_cos_fixed)){
#   lines(avg_cos_fixed[[j]][2, ], col = alpha("black", 0.3))
# }
# 
# plot(avg_cos_kl[[1]][2, ], type = "l", ylim = c(0, 0.4), ylab = "stdev. of cosine error", xlab = "theta", col = alpha("black", 0.3), , main = "KL")
# for(j in 2:length(avg_cos)){
#   lines(avg_cos_kl[[j]][2, ], col = alpha("black", 0.3))
# }
# 

mean_kl <- as.matrix(data.frame(lapply(avg_cos_kl, function(x) x[1,])))
mean_conc <- as.matrix(data.frame(lapply(avg_cos_conc, function(x) x[1,])))
mean_fixed <- as.matrix(data.frame(lapply(avg_cos_fixed, function(x) x[1,])))

sd_kl <- as.matrix(data.frame(lapply(avg_cos_kl, function(x) x[2,])))
sd_conc <- as.matrix(data.frame(lapply(avg_cos_conc, function(x) x[2,])))
sd_fixed <- as.matrix(data.frame(lapply(avg_cos_fixed, function(x) x[2,])))

par(mfrow = c(2, 3))
# Mean
plot(rowMeans(mean_fixed), type="l", main = "fixed", ylab = "avg. cosine error", xlab = "alpha", ylim = c(0, 1))
lines(apply(mean_fixed,1, function(x) quantile(x, 0.25) ), col = "red", lty = "dashed")
lines(apply(mean_fixed,1, function(x) quantile(x, 0.75) ), col = "red", lty = "dashed")

plot(rowMeans(mean_conc), type="l", main = "concentration", ylab = "avg. cosine error", xlab = "theta", ylim = c(0, 1))
lines(apply(mean_conc,1, function(x) quantile(x, 0.25) ), col = "red", lty = "dashed")
lines(apply(mean_conc,1, function(x) quantile(x, 0.75) ), col = "red", lty = "dashed")

plot(rowMeans(mean_kl), type="l", main = "KL", ylab = "avg. cosine error", xlab = "theta", ylim = c(0, 1))
lines(apply(mean_kl,1, function(x) quantile(x, 0.25) ), col = "red", lty = "dashed")
lines(apply(mean_kl,1, function(x) quantile(x, 0.75) ), col = "red", lty = "dashed")

# stdev
plot(rowMeans(sd_fixed), type="l", main = "fixed", ylab = "std. cosine error", xlab = "alpha", ylim = c(0, 0.2))
lines(apply(sd_fixed,1, function(x) quantile(x, 0.25) ), col = "red", lty = "dashed")
lines(apply(sd_fixed,1, function(x) quantile(x, 0.75) ), col = "red", lty = "dashed")

plot(rowMeans(sd_conc), type="l", main = "concentration", ylab = "std. cosine error", xlab = "theta", ylim = c(0, 0.2))
lines(apply(sd_conc,1, function(x) quantile(x, 0.25) ), col = "red", lty = "dashed")
lines(apply(sd_conc,1, function(x) quantile(x, 0.75) ), col = "red", lty = "dashed")

plot(rowMeans(sd_kl), type="l", main = "KL", ylab = "std. cosine error", xlab = "theta", ylim = c(0, 0.2))
lines(apply(sd_kl,1, function(x) quantile(x, 0.25) ), col = "red", lty = "dashed")
lines(apply(sd_kl,1, function(x) quantile(x, 0.75) ), col = "red", lty = "dashed")

```
















```{R}
# We need to be consistent with the choice of the spread

# Fix one level of alpha, and look at the distribution of the cosine similarities for
# all signatures
res_kl <- vector(mode = "list", length = ncol(X))
range_kl <- c(1, 2, 3, 5, 10, 15, 20, 100, 120, 150, 200)
nsamples <- 5000
for(j in 1:ncol(X)){
  print(j)
  x <- X[, j]
  res <- matrix(NA, nrow = nsamples, ncol = length(range_kl))
  for(i in 1:length(range_kl)){
    alpha_new <- julia_call("max_density_for_dirichlet", x, range_kl[i], "kl_uniform")
    cosine_samples <- apply(rdir(nsamples, alpha_new),  1, function(y) 1 - lsa::cosine(x, y))
    res[, i] <- cosine_samples
  }
  res_kl[[j]] <- res
}
names(res_kl) <- colnames(X)
```


```{R}
# Calculate the alpha for each signature in the data using the KL method
get_alpha_kl <- function(x, range_kl = c(1:200)){
  res <- sapply(range_kl, function(k) julia_call("max_density_for_dirichlet", x, range_kl[i], "kl_uniform"))
  rownames(res) <- names(x)
  return(res)
}
alpha_all_kl <- apply(X[, 1:3], 2, function(x) get_alpha_kl(x))

```


```{R}
do.call("rbind", lapply(res_kl, function(x) colMeans(x)))
```









